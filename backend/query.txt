-- 1. Users Table
CREATE TABLE IF NOT EXISTS users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    full_name VARCHAR(100),
    email VARCHAR(150) UNIQUE NOT NULL,
    password_hash TEXT NOT NULL,
    profile_picture TEXT,
    company_name VARCHAR(100),
    email_verified BOOLEAN DEFAULT FALSE,
    plan_status VARCHAR(50) DEFAULT 'free' NOT NULL, -- New field
    paddle_customer_id TEXT UNIQUE,                 -- New field
    paddle_current_subscription_id TEXT UNIQUE,     -- New field
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 2. Email Verification Tokens
CREATE TABLE email_verification_tokens (
    id SERIAL PRIMARY KEY,
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    token TEXT UNIQUE NOT NULL,
    expires_at TIMESTAMP NOT NULL
);

-- 3. Password Reset Tokens
CREATE TABLE password_reset_tokens (
    id SERIAL PRIMARY KEY,
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    token TEXT UNIQUE NOT NULL,
    expires_at TIMESTAMP NOT NULL
);

-- 4. Subscription Plans
CREATE TABLE plans (
    id SERIAL PRIMARY KEY,
    name VARCHAR(50) UNIQUE,
    price_usd DECIMAL(10,2),
    max_predictions_per_month INTEGER,
    description TEXT
);

-- 5. Subscriptions
CREATE TABLE IF NOT EXISTS subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(), -- Unique ID for your subscription record
    user_id UUID NOT NULL REFERENCES users(id),     -- Foreign key to your custom 'users' table
    paddle_subscription_id TEXT UNIQUE NOT NULL,    -- Paddle's unique subscription ID (e.g., 'sub_01h...')
    paddle_price_id TEXT NOT NULL,                  -- Paddle's price ID (e.g., 'pri_01h...')
    status TEXT NOT NULL,                           -- Current status: 'active', 'trialing', 'past_due', 'canceled', 'paused', 'expired'
    current_period_start TIMESTAMP WITH TIME ZONE,  -- Start of the current billing period
    current_period_end TIMESTAMP WITH TIME ZONE,    -- End of the current billing period
    next_billed_at TIMESTAMP WITH TIME ZONE,        -- Next billing date (for recurring subscriptions)
    cancel_at_period_end BOOLEAN DEFAULT FALSE,     -- True if subscription will cancel at period end
    unit_price_amount NUMERIC(10, 2),               -- Price per unit (if applicable)
    quantity INTEGER DEFAULT 1,                     -- Quantity of the subscription (e.g., seats)
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 6. Payments
CREATE TABLE payments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    plan_id INTEGER REFERENCES plans(id),
    amount DECIMAL(10,2),
    currency VARCHAR(10),
    status VARCHAR(20),
    payment_date TIMESTAMP,
    stripe_payment_intent_id TEXT
);

-- 7. API Keys
CREATE TABLE api_keys (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    api_key TEXT UNIQUE NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 8. API Usage Logs
CREATE TABLE api_usage_logs (
    id SERIAL PRIMARY KEY,
    api_key_id UUID REFERENCES api_keys(id),
    endpoint TEXT,
    used_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    status_code INTEGER,
    ip_address TEXT
);

-- 9. Meeting Inputs
CREATE TABLE meetings (
    meeting_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,

    meeting_title TEXT,
    agenda_format TEXT,
    agenda_file TEXT DEFAULT NULL, -- Store file path or URL
    time_block TEXT,
    remote BOOLEAN,
    tool TEXT,
    meeting_type TEXT,
    duration INTEGER,
    attendees INTEGER,
    agenda_clarity INTEGER[], -- Using array for number[]
    has_action_items BOOLEAN,
    departments TEXT,
    roles TEXT,
    average_annual_salary FLOAT,
    meeting_notes TEXT,

    roi FLOAT DEFAULT NULL, -- Will be calculated later
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
CREATE TABLE meeting_predictions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    meeting_id UUID REFERENCES meetings(meeting_id) ON DELETE CASCADE,
    is_productive BOOLEAN,
    confidence_score DECIMAL(5,2),
    predicted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    roi DECIMAL(10,2),
    estimated_cost FLOAT,
    estimated_value_gain_on_meeting FLOAT,
    suggestions TEXT
);


-- 11. Admin Users
CREATE TABLE admin_users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(150) UNIQUE,
    password_hash TEXT NOT NULL,
    is_superadmin BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 12. Contact Messages
CREATE TABLE contact_messages (
    id SERIAL PRIMARY KEY,
    user_id UUID REFERENCES users(id),
    name VARCHAR(100),
    email VARCHAR(150),
    message TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
-- Insert basic subscription plans
INSERT INTO plans (name, price_usd, max_predictions_per_month, description) VALUES
('Free', 0.00, 100, 'Basic plan with limited monthly predictions.'),
('Pro', 29.00, 10000, 'For individuals and startups with higher usage.'),
('Business', 99.00, 50000, 'Advanced usage for teams and organizations.'),
('Enterprise', 0.00, NULL, 'Custom plan for large companies, contact sales.');

--Get all predictions with user details
SELECT u.full_name, u.email, m.duration_minutes, p.is_productive, p.confidence_score
FROM meeting_predictions p
JOIN meeting_inputs m ON p.meeting_id = m.id
JOIN users u ON m.user_id = u.id
ORDER BY p.predicted_at DESC;

--Monthly api usage per user
SELECT u.full_name, COUNT(*) AS total_calls, DATE_TRUNC('month', a.used_at) AS month
FROM api_usage_logs a
JOIN api_keys k ON a.api_key_id = k.id
JOIN users u ON k.user_id = u.id
GROUP BY u.full_name, month
ORDER BY month DESC, total_calls DESC;

--Active subscription with plan name
SELECT u.email, p.name AS plan_name, s.status, s.start_date, s.end_date
FROM subscriptions s
JOIN users u ON s.user_id = u.id
JOIN plans p ON s.plan_id = p.id
WHERE s.status = 'active';

--counts of predictions used this month(per plan)
SELECT p.name AS plan_name, COUNT(mp.id) AS predictions_this_month
FROM users u
JOIN subscriptions s ON u.id = s.user_id
JOIN plans p ON s.plan_id = p.id
JOIN meeting_inputs mi ON u.id = mi.user_id
JOIN meeting_predictions mp ON mp.meeting_id = mi.id
WHERE mp.predicted_at >= date_trunc('month', CURRENT_DATE)
GROUP BY p.name;

DROP VIEW IF EXISTS meeting_overview;

CREATE VIEW meeting_overview AS
SELECT
    mi.user_id,
    COALESCE(SUM(mp.estimated_cost), 0) AS total_estimated_cost,
    COUNT(mp.id) AS total_meeting_analyzed,
    COALESCE(SUM(mp.roi), 0) AS total_roi,
    COALESCE(SUM(mp.estimated_value_gain_on_meeting), 0) AS total_estimated_value_gain,
    COUNT(*) FILTER (WHERE mp.is_productive = TRUE) AS total_productive_meetings
FROM meeting_predictions mp
JOIN meetings mi ON mp.meeting_id = mi.meeting_id
GROUP BY mi.user_id;




CREATE VIEW recent_predictions AS
SELECT
    mp.id AS id,
    mi.meeting_title,
    mp.predicted_at AS date,
    mp.is_productive,
    mp.confidence_score
FROM meeting_predictions mp
JOIN meetings mi ON mp.meeting_id = mi.meeting_id
ORDER BY mp.predicted_at DESC
LIMIT 10;





ALTER TABLE subscriptions ADD COLUMN plan_id INTEGER;
ALTER TABLE subscriptions ADD CONSTRAINT fk_plan_id FOREIGN KEY (plan_id) REFERENCES plans(id);

ALTER TABLE users
ADD COLUMN plan_id INTEGER REFERENCES plans(id) ON DELETE SET NULL;
INSERT INTO plans (name, price_usd, max_predictions_per_month, description)
VALUES 
  ('free', 0.00, 20, 'Basic plan with limited access'),
  ('pro', 25.00, 100, 'Pro plan for power users'),
  ('business', 59.00, 500, 'Business tier for teams')
ON CONFLICT (name) DO NOTHING;

ALTER TABLE users
ADD COLUMN predictions_used INTEGER DEFAULT 0,
ADD COLUMN plan_updated_at TIMESTAMP DEFAULT NOW();

ALTER TABLE meeting_predictions
ADD COLUMN created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP;

UPDATE plans
SET max_predictions_per_month = CASE
	WHEN name='free' THEN 3
	WHEN name='pro' THEN 30
	WHEN name = 'business' THEN 50
	ELSE max_predictions_per_month
END;